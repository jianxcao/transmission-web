---
description: API 调用和数据处理规范（Transmission RPC）
globs: **/api/**/*.ts, **/store/**/*.ts
alwaysApply: false
---

# API 和数据处理规范

针对 Transmission RPC API 的最佳实践

## API 层设计

### API 文件组织
```
api/
├── rpc.ts           # Transmission RPC 核心接口
├── trpc.ts          # tRPC 配置
├── types.ts         # API 类型定义
└── interceptors.ts  # 请求拦截器（可选）
```

### RPC 方法封装
```typescript
// api/rpc.ts
import axios, { AxiosInstance } from 'axios'

class TransmissionRPC {
  private client: AxiosInstance
  private sessionId: string = ''
  
  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      headers: {
        'Content-Type': 'application/json'
      }
    })
    
    this.setupInterceptors()
  }
  
  // ✅ 统一的 RPC 调用方法
  private async call<T = any>(
    method: string, 
    arguments?: Record<string, any>
  ): Promise<T> {
    try {
      const response = await this.client.post('/rpc', {
        method,
        arguments
      }, {
        headers: {
          'X-Transmission-Session-Id': this.sessionId
        }
      })
      
      if (response.data.result !== 'success') {
        throw new Error(response.data.result)
      }
      
      return response.data.arguments as T
    } catch (error) {
      this.handleError(error)
      throw error
    }
  }
  
  // ✅ 具体的 API 方法
  async getTorrents(ids?: number[]): Promise<TorrentInfo[]> {
    const args = ids ? { ids } : {}
    const result = await this.call<{ torrents: TorrentInfo[] }>(
      'torrent-get',
      {
        ...args,
        fields: TORRENT_FIELDS
      }
    )
    return result.torrents
  }
  
  async addTorrent(options: AddTorrentOptions): Promise<TorrentInfo> {
    const result = await this.call<{ torrent-added: TorrentInfo }>(
      'torrent-add',
      options
    )
    return result['torrent-added']
  }
}

export const rpc = new TransmissionRPC(
  import.meta.env.VITE_RPC_URL || '/transmission/rpc'
)
```

## 错误处理

### 统一错误处理
```typescript
// api/errors.ts
export class TransmissionError extends Error {
  constructor(
    message: string,
    public code?: string,
    public statusCode?: number
  ) {
    super(message)
    this.name = 'TransmissionError'
  }
}

export class SessionIdError extends TransmissionError {
  constructor() {
    super('Invalid session ID', 'SESSION_ID_ERROR', 409)
  }
}

export class NetworkError extends TransmissionError {
  constructor(message: string) {
    super(message, 'NETWORK_ERROR')
  }
}

// api/rpc.ts
private handleError(error: any): void {
  // 409 错误：需要更新 Session ID
  if (error.response?.status === 409) {
    const sessionId = error.response.headers['x-transmission-session-id']
    if (sessionId) {
      this.sessionId = sessionId
      throw new SessionIdError()
    }
  }
  
  // 网络错误
  if (!error.response) {
    throw new NetworkError('Network connection failed')
  }
  
  // 其他错误
  throw new TransmissionError(
    error.response?.data?.message || error.message,
    'UNKNOWN_ERROR',
    error.response?.status
  )
}
```

### 组件中的错误处理
```typescript
// ✅ 使用 try-catch 和用户友好的提示
import { useMessage } from 'naive-ui'

const message = useMessage()

async function handleAddTorrent() {
  try {
    await rpc.addTorrent({ filename: magnetLink })
    message.success('种子添加成功')
  } catch (error) {
    if (error instanceof SessionIdError) {
      // 自动重试
      return handleAddTorrent()
    }
    
    if (error instanceof NetworkError) {
      message.error('网络连接失败，请检查连接')
    } else {
      message.error('添加种子失败')
    }
    
    console.error('Failed to add torrent:', error)
  }
}
```

## 数据处理

### JSON 解析
```typescript
// ✅ 始终使用 try-catch 处理 JSON 解析
function parseStoredConfig(): Config {
  try {
    const json = localStorage.getItem('config')
    if (!json) {
      return DEFAULT_CONFIG
    }
    return JSON.parse(json)
  } catch (error) {
    console.error('Failed to parse config:', error)
    return DEFAULT_CONFIG
  }
}

// ✅ 使用类型守卫验证解析结果
function isValidConfig(data: unknown): data is Config {
  return (
    typeof data === 'object' &&
    data !== null &&
    'theme' in data &&
    'language' in data
  )
}

function loadConfig(): Config {
  try {
    const json = localStorage.getItem('config')
    if (!json) return DEFAULT_CONFIG
    
    const data = JSON.parse(json)
    if (isValidConfig(data)) {
      return data
    }
    
    console.warn('Invalid config format, using default')
    return DEFAULT_CONFIG
  } catch (error) {
    console.error('Failed to load config:', error)
    return DEFAULT_CONFIG
  }
}
```

### 数据转换
```typescript
// ✅ 将 API 数据转换为应用数据
interface RpcTorrent {
  id: number
  name: string
  totalSize: number
  downloadedEver: number
  status: number
  rateDownload: number
  rateUpload: number
}

interface TorrentInfo {
  id: number
  name: string
  totalSize: number
  downloadedSize: number
  status: TorrentStatus
  downloadSpeed: number
  uploadSpeed: number
  progress: number
}

// 转换函数
function transformTorrent(rpc: RpcTorrent): TorrentInfo {
  return {
    id: rpc.id,
    name: rpc.name,
    totalSize: rpc.totalSize,
    downloadedSize: rpc.downloadedEver,
    status: getRpcStatus(rpc.status),
    downloadSpeed: rpc.rateDownload,
    uploadSpeed: rpc.rateUpload,
    progress: rpc.totalSize > 0 
      ? (rpc.downloadedEver / rpc.totalSize) * 100 
      : 0
  }
}

// 状态映射
function getRpcStatus(status: number): TorrentStatus {
  const STATUS_MAP: Record<number, TorrentStatus> = {
    0: 'stopped',
    1: 'checking',
    2: 'checking',
    3: 'downloading',
    4: 'downloading',
    5: 'seeding',
    6: 'seeding'
  }
  return STATUS_MAP[status] || 'stopped'
}
```

### 数据验证
```typescript
// ✅ 验证 API 响应数据
function validateTorrentResponse(data: unknown): data is { torrents: RpcTorrent[] } {
  if (typeof data !== 'object' || data === null) {
    return false
  }
  
  if (!('torrents' in data) || !Array.isArray(data.torrents)) {
    return false
  }
  
  return data.torrents.every(t => 
    typeof t === 'object' &&
    typeof t.id === 'number' &&
    typeof t.name === 'string' &&
    typeof t.totalSize === 'number'
  )
}

// 使用
async function fetchTorrents(): Promise<TorrentInfo[]> {
  try {
    const response = await rpc.call('torrent-get', {
      fields: TORRENT_FIELDS
    })
    
    if (!validateTorrentResponse(response)) {
      throw new Error('Invalid response format')
    }
    
    return response.torrents.map(transformTorrent)
  } catch (error) {
    console.error('Failed to fetch torrents:', error)
    throw error
  }
}
```

## Store 中的数据管理

### 异步操作
```typescript
// store/torrent.ts
export const useTorrentStore = defineStore('torrent', () => {
  const torrents = ref<TorrentInfo[]>([])
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  // ✅ 统一的加载状态管理
  async function fetchTorrents(): Promise<void> {
    loading.value = true
    error.value = null
    
    try {
      const data = await rpc.getTorrents()
      torrents.value = data
    } catch (e) {
      error.value = e as Error
      throw e
    } finally {
      loading.value = false
    }
  }
  
  // ✅ 乐观更新
  async function updateTorrent(
    id: number, 
    updates: Partial<TorrentInfo>
  ): Promise<void> {
    // 保存旧值用于回滚
    const index = torrents.value.findIndex(t => t.id === id)
    if (index === -1) return
    
    const oldTorrent = { ...torrents.value[index] }
    
    // 立即更新 UI
    torrents.value[index] = { ...oldTorrent, ...updates }
    
    try {
      await rpc.setTorrent(id, updates)
    } catch (error) {
      // 回滚
      torrents.value[index] = oldTorrent
      throw error
    }
  }
  
  return {
    torrents: readonly(torrents),
    loading: readonly(loading),
    error: readonly(error),
    fetchTorrents,
    updateTorrent
  }
})
```

### 轮询更新
```typescript
// composables/usePolling.ts
export function usePolling(
  callback: () => Promise<void>,
  interval: number = 3000
) {
  const isPolling = ref(false)
  let timerId: number | null = null
  
  async function poll() {
    if (!isPolling.value) return
    
    try {
      await callback()
    } catch (error) {
      console.error('Polling error:', error)
    }
    
    if (isPolling.value) {
      timerId = window.setTimeout(poll, interval)
    }
  }
  
  function start() {
    if (isPolling.value) return
    isPolling.value = true
    poll()
  }
  
  function stop() {
    isPolling.value = false
    if (timerId !== null) {
      clearTimeout(timerId)
      timerId = null
    }
  }
  
  // 组件卸载时自动停止
  onUnmounted(stop)
  
  return {
    isPolling: readonly(isPolling),
    start,
    stop
  }
}

// 使用
const torrentStore = useTorrentStore()
const { start, stop } = usePolling(
  () => torrentStore.fetchTorrents(),
  3000
)

onMounted(start)
```

## 请求优化

### 请求合并
```typescript
// ✅ 合并多个请求
async function fetchAllData(): Promise<void> {
  const [torrents, session, stats] = await Promise.all([
    rpc.getTorrents(),
    rpc.getSession(),
    rpc.getStats()
  ])
  
  // 更新 store
  torrentStore.setTorrents(torrents)
  sessionStore.setSession(session)
  statsStore.setStats(stats)
}
```

### 请求取消
```typescript
// ✅ 使用 AbortController 取消请求
export function useAbortableRequest<T>(
  requestFn: (signal: AbortSignal) => Promise<T>
) {
  const controller = ref<AbortController>()
  const loading = ref(false)
  
  async function execute(): Promise<T | undefined> {
    // 取消之前的请求
    controller.value?.abort()
    
    controller.value = new AbortController()
    loading.value = true
    
    try {
      const result = await requestFn(controller.value.signal)
      return result
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Request aborted')
        return undefined
      }
      throw error
    } finally {
      loading.value = false
    }
  }
  
  onUnmounted(() => {
    controller.value?.abort()
  })
  
  return {
    execute,
    loading: readonly(loading)
  }
}
```

### 缓存策略
```typescript
// ✅ 简单的内存缓存
class CachedRPC {
  private cache = new Map<string, { data: any, timestamp: number }>()
  private ttl = 5000 // 5 秒
  
  async get<T>(
    key: string, 
    fetcher: () => Promise<T>
  ): Promise<T> {
    const cached = this.cache.get(key)
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data
    }
    
    const data = await fetcher()
    this.cache.set(key, { data, timestamp: Date.now() })
    
    return data
  }
  
  clear(key?: string): void {
    if (key) {
      this.cache.delete(key)
    } else {
      this.cache.clear()
    }
  }
}
```

## 最佳实践总结

1. **错误处理**: 始终使用 try-catch，提供用户友好的错误提示
2. **JSON 解析**: 使用 try-catch 保护 JSON.parse 操作
3. **数据验证**: 使用类型守卫验证 API 响应
4. **数据转换**: 将 API 数据转换为应用数据模型
5. **加载状态**: 统一管理 loading 和 error 状态
6. **乐观更新**: 提供即时反馈，失败时回滚
7. **请求优化**: 合并请求、实现缓存、支持取消
8. **类型安全**: 使用 TypeScript 类型定义所有 API 接口
